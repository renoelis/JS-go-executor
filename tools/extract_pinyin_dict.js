#!/usr/bin/env node
/**
 * ä» pinyin.min.js æå–æ‹¼éŸ³å­—å…¸æ•°æ®å¹¶ç”Ÿæˆ Go ä»£ç 
 * 
 * ç”¨æ³•: node tools/extract_pinyin_dict.js
 */

const fs = require('fs');
const path = require('path');

// æ–‡ä»¶è·¯å¾„
const INPUT_FILE = path.join(__dirname, '../assets/external-libs/pinyin.min.js');
const OUTPUT_DIR = path.join(__dirname, '../enhance_modules/pinyin/dict');
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'dict_gen.go');
const PHRASES_OUTPUT_FILE = path.join(OUTPUT_DIR, 'phrases_gen.go');

// ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

console.log('ğŸ“– è¯»å– pinyin.min.js...');
const content = fs.readFileSync(INPUT_FILE, 'utf-8');

// æå–å­—å…¸æ•°æ®
console.log('ğŸ” æå–å­—å…¸æ•°æ®...');
const dictEntries = [];
const dictRegex = /dict\[0x([0-9A-Fa-f]+)\]\s*=\s*"([^"]+)";/g;

let match;
let count = 0;
while ((match = dictRegex.exec(content)) !== null) {
    const unicode = match[1]; // åå…­è¿›åˆ¶ Unicode
    const pinyins = match[2];  // æ‹¼éŸ³å­—ç¬¦ä¸²
    
    dictEntries.push({
        unicode: unicode,
        decimal: parseInt(unicode, 16),
        char: String.fromCodePoint(parseInt(unicode, 16)),
        pinyins: pinyins.split(',').map(p => p.trim())
    });
    
    count++;
    if (count % 1000 === 0) {
        console.log(`  å·²æå– ${count} ä¸ªå­—ç¬¦...`);
    }
}

console.log(`âœ… æˆåŠŸæå– ${dictEntries.length} ä¸ªæ±‰å­—çš„æ‹¼éŸ³æ•°æ®`);

// ç”Ÿæˆ Go ä»£ç 
console.log('ğŸ”¨ ç”Ÿæˆ Go ä»£ç ...');

let goCode = `// Code generated by tools/extract_pinyin_dict.js. DO NOT EDIT.
// Source: assets/external-libs/pinyin.min.js (v4.0.0)
// Generated at: ${new Date().toISOString()}
// Total entries: ${dictEntries.length}

package dict

// CharDict æ±‰å­—æ‹¼éŸ³å­—å…¸
// Key: Unicode ç ç‚¹ (rune)
// Value: æ‹¼éŸ³åˆ—è¡¨ (å¸¦å£°è°ƒ,æŒ‰ä½¿ç”¨é¢‘ç‡æ’åº)
var CharDict = map[rune][]string{
`;

// æŒ‰ Unicode æ’åºä»¥ä¾¿æŸ¥çœ‹
dictEntries.sort((a, b) => a.decimal - b.decimal);

// ç”Ÿæˆå­—å…¸æ¡ç›®
for (const entry of dictEntries) {
    const pinyinsStr = entry.pinyins.map(p => `"${p}"`).join(', ');
    const comment = ` // ${entry.char}`;
    goCode += `\t0x${entry.unicode.toUpperCase()}: {${pinyinsStr}},${comment}\n`;
}

goCode += `}\n\n`;

// æ·»åŠ è¾…åŠ©å‡½æ•°å’Œç»Ÿè®¡ä¿¡æ¯
goCode += `// DictStats å­—å…¸ç»Ÿè®¡ä¿¡æ¯
var DictStats = struct {
    TotalChars      int // æ€»å­—ç¬¦æ•°
    MultiPronounced int // å¤šéŸ³å­—æ•°é‡
    MaxPronounced   int // æœ€å¤šè¯»éŸ³æ•°
}{
    TotalChars:      ${dictEntries.length},
    MultiPronounced: ${dictEntries.filter(e => e.pinyins.length > 1).length},
    MaxPronounced:   ${Math.max(...dictEntries.map(e => e.pinyins.length))},
}

// GetPinyin è·å–å•ä¸ªæ±‰å­—çš„æ‹¼éŸ³
func GetPinyin(char rune) ([]string, bool) {
    pinyins, exists := CharDict[char]
    return pinyins, exists
}

// HasChar æ£€æŸ¥å­—ç¬¦æ˜¯å¦åœ¨å­—å…¸ä¸­
func HasChar(char rune) bool {
    _, exists := CharDict[char]
    return exists
}

// IsMultiPronounced æ£€æŸ¥æ˜¯å¦æ˜¯å¤šéŸ³å­—
func IsMultiPronounced(char rune) bool {
    pinyins, exists := CharDict[char]
    return exists && len(pinyins) > 1
}
`;

// å†™å…¥æ–‡ä»¶
fs.writeFileSync(OUTPUT_FILE, goCode, 'utf-8');
console.log(`âœ… æˆåŠŸç”Ÿæˆ: ${OUTPUT_FILE}`);

// ç”Ÿæˆç»Ÿè®¡æŠ¥å‘Š
const stats = {
    totalChars: dictEntries.length,
    singlePronounced: dictEntries.filter(e => e.pinyins.length === 1).length,
    multiPronounced: dictEntries.filter(e => e.pinyins.length > 1).length,
    maxPronounced: Math.max(...dictEntries.map(e => e.pinyins.length)),
    maxPronouncedChar: dictEntries.find(e => 
        e.pinyins.length === Math.max(...dictEntries.map(e => e.pinyins.length))
    )
};

console.log('\nğŸ“Š å­—å…¸ç»Ÿè®¡:');
console.log(`  æ€»å­—ç¬¦æ•°: ${stats.totalChars}`);
console.log(`  å•éŸ³å­—: ${stats.singlePronounced} (${(stats.singlePronounced/stats.totalChars*100).toFixed(1)}%)`);
console.log(`  å¤šéŸ³å­—: ${stats.multiPronounced} (${(stats.multiPronounced/stats.totalChars*100).toFixed(1)}%)`);
console.log(`  æœ€å¤šè¯»éŸ³æ•°: ${stats.maxPronounced}`);
if (stats.maxPronouncedChar) {
    console.log(`  è¯»éŸ³æœ€å¤šçš„å­—: ${stats.maxPronouncedChar.char} (${stats.maxPronouncedChar.pinyins.join(', ')})`);
}

// ç”Ÿæˆç¤ºä¾‹æ–‡ä»¶
const exampleFile = path.join(OUTPUT_DIR, 'dict_example.txt');
const examples = dictEntries.slice(0, 50).map(e => 
    `${e.char} (U+${e.unicode.toUpperCase()}): ${e.pinyins.join(', ')}`
).join('\n');

fs.writeFileSync(exampleFile, `æ‹¼éŸ³å­—å…¸ç¤ºä¾‹ (å‰50ä¸ªå­—ç¬¦)\n\n${examples}\n`, 'utf-8');
console.log(`âœ… ç”Ÿæˆç¤ºä¾‹æ–‡ä»¶: ${exampleFile}`);

// ============================================================================
// æå–è¯ç»„å­—å…¸ (phrases_dict)
// ============================================================================

console.log('\n\nğŸ” æå–è¯ç»„å­—å…¸ (phrases_dict)...');

const phrasesRegex = /"([^"]+)":\s*\[\s*(\[.*?\])\s*\]/g;
const phrasesSection = content.match(/const phrases_dict = \{[\s\S]*?\n  \};/);

if (!phrasesSection) {
    console.log('âŒ æœªæ‰¾åˆ° phrases_dict');
} else {
    const phrasesEntries = [];
    let phrasesMatch;
    let phrasesCount = 0;
    
    while ((phrasesMatch = phrasesRegex.exec(phrasesSection[0])) !== null) {
        const phrase = phrasesMatch[1];
        const pinyinsStr = phrasesMatch[2];
        
        // è§£ææ‹¼éŸ³æ•°ç»„: [["zhÅng"], ["guÃ³"]] -> [["zhÅng"], ["guÃ³"]]
        try {
            const pinyins = JSON.parse(`[${pinyinsStr}]`);
            phrasesEntries.push({
                phrase: phrase,
                pinyins: pinyins
            });
            
            phrasesCount++;
            if (phrasesCount % 1000 === 0) {
                console.log(`  å·²æå– ${phrasesCount} ä¸ªè¯ç»„...`);
            }
        } catch (e) {
            console.log(`  âš ï¸  è§£æå¤±è´¥: ${phrase}`);
        }
    }
    
    console.log(`âœ… æˆåŠŸæå– ${phrasesEntries.length} ä¸ªè¯ç»„`);
    
    // ç”Ÿæˆè¯ç»„å­—å…¸ Go ä»£ç 
    console.log('ğŸ”¨ ç”Ÿæˆè¯ç»„å­—å…¸ Go ä»£ç ...');
    
    let phrasesGoCode = `// Code generated by tools/extract_pinyin_dict.js. DO NOT EDIT.
// Source: assets/external-libs/pinyin.min.js (v4.0.0)
// Generated at: ${new Date().toISOString()}
// Total entries: ${phrasesEntries.length}

package dict

// PhrasesDict è¯ç»„æ‹¼éŸ³å­—å…¸
// Key: è¯ç»„å­—ç¬¦ä¸²
// Value: æ¯ä¸ªå­—çš„æ‹¼éŸ³æ•°ç»„
// ç”¨äºè§£å†³å¤šéŸ³å­—æ­§ä¹‰,å¦‚ "é“¶è¡Œ" ä¸­çš„ "è¡Œ" è¯» hÃ¡ng è€Œä¸æ˜¯ xÃ­ng
var PhrasesDict = map[string][][]string{
`;
    
    // ä¿æŒåŸå§‹é¡ºåº (æŒ‰ç…§ pinyin.min.js ä¸­çš„é¡ºåº)
    // phrasesEntries å·²ç»æŒ‰ç…§æ–‡ä»¶ä¸­å‡ºç°çš„é¡ºåºäº†,ä¸éœ€è¦é‡æ–°æ’åº
    
    for (const entry of phrasesEntries) {
        // è½¬ä¹‰å¼•å·å’Œåæ–œæ 
        const phrase = entry.phrase.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        
        // æ„å»ºæ‹¼éŸ³æ•°ç»„
        const pinyinsArray = entry.pinyins.map(pyGroup => {
            return '{' + pyGroup.map(py => `"${py}"`).join(', ') + '}';
        }).join(', ');
        
        phrasesGoCode += `\t"${phrase}": {${pinyinsArray}},\n`;
    }
    
    phrasesGoCode += `}\n\n`;
    
    // æ·»åŠ å·¥å…·å‡½æ•°
    phrasesGoCode += `// GetPhrasePinyin è·å–è¯ç»„çš„æ‹¼éŸ³
func GetPhrasePinyin(phrase string) ([][]string, bool) {
    pinyins, exists := PhrasesDict[phrase]
    return pinyins, exists
}

// HasPhrase æ£€æŸ¥è¯ç»„æ˜¯å¦åœ¨å­—å…¸ä¸­
func HasPhrase(phrase string) bool {
    _, exists := PhrasesDict[phrase]
    return exists
}

// PhrasesStats è¯ç»„å­—å…¸ç»Ÿè®¡
var PhrasesStats = struct {
    TotalPhrases int // æ€»è¯ç»„æ•°
    MaxLength    int // æœ€é•¿è¯ç»„å­—æ•°
}{
    TotalPhrases: ${phrasesEntries.length},
    MaxLength:    ${Math.max(...phrasesEntries.map(e => e.phrase.length))},
}
`;
    
    // å†™å…¥æ–‡ä»¶
    fs.writeFileSync(PHRASES_OUTPUT_FILE, phrasesGoCode, 'utf-8');
    console.log(`âœ… æˆåŠŸç”Ÿæˆ: ${PHRASES_OUTPUT_FILE}`);
    
    // è¯ç»„ç»Ÿè®¡
    const phrasesStats = {
        total: phrasesEntries.length,
        twoChar: phrasesEntries.filter(e => e.phrase.length === 2).length,
        threeChar: phrasesEntries.filter(e => e.phrase.length === 3).length,
        fourChar: phrasesEntries.filter(e => e.phrase.length === 4).length,
        moreThanFour: phrasesEntries.filter(e => e.phrase.length > 4).length,
        maxLength: Math.max(...phrasesEntries.map(e => e.phrase.length)),
        examples: phrasesEntries.slice(0, 10)
    };
    
    console.log('\nğŸ“Š è¯ç»„å­—å…¸ç»Ÿè®¡:');
    console.log(`  æ€»è¯ç»„æ•°: ${phrasesStats.total}`);
    console.log(`  äºŒå­—è¯: ${phrasesStats.twoChar} (${(phrasesStats.twoChar/phrasesStats.total*100).toFixed(1)}%)`);
    console.log(`  ä¸‰å­—è¯: ${phrasesStats.threeChar} (${(phrasesStats.threeChar/phrasesStats.total*100).toFixed(1)}%)`);
    console.log(`  å››å­—è¯: ${phrasesStats.fourChar} (${(phrasesStats.fourChar/phrasesStats.total*100).toFixed(1)}%)`);
    console.log(`  æ›´é•¿è¯: ${phrasesStats.moreThanFour} (${(phrasesStats.moreThanFour/phrasesStats.total*100).toFixed(1)}%)`);
    console.log(`  æœ€é•¿è¯ç»„: ${phrasesStats.maxLength} å­—`);
    
    // ç”Ÿæˆè¯ç»„ç¤ºä¾‹æ–‡ä»¶
    const phrasesExampleFile = path.join(OUTPUT_DIR, 'phrases_example.txt');
    const phrasesExamples = phrasesStats.examples.map(e => 
        `${e.phrase}: ${e.pinyins.map(py => py.join('')).join(' ')}`
    ).join('\n');
    
    fs.writeFileSync(phrasesExampleFile, `è¯ç»„å­—å…¸ç¤ºä¾‹ (å‰10ä¸ª)\n\n${phrasesExamples}\n`, 'utf-8');
    console.log(`âœ… ç”Ÿæˆç¤ºä¾‹æ–‡ä»¶: ${phrasesExampleFile}`);
}

console.log('\n\nğŸ‰ å­—å…¸æå–å®Œæˆ!');
console.log('\nä¸‹ä¸€æ­¥:');
console.log('  1. cd enhance_modules/pinyin/dict');
console.log('  2. go fmt *.go');
console.log('  3. ç¼–è¯‘æµ‹è¯•: go build');

